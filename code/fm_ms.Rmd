---
title: "fm.ms"
author: "M. Florencia Miguel"
date: "14 de junio de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Initialize loading the required `R` packages.

```{r initialize, echo= T, message= FALSE, warning=FALSE}

library(ggplot2)
library(statnet)
library(igraph)
library(sna)
library(ergm)
library(ggnetwork)
library(GGally)
library(bipartite)
```

# NETWORKS

```{r}
main<- read.csv("../data/interaction_matrix.csv", header= T, sep= ",",
                dec = ".", na.strings = "NA")
str(main)

```


```{r adj_mat, echo= T}

grazed<- main %>% 
           dplyr::filter(site=="grazed") %>%  
           dplyr::select(1,32:43) 


ungrazed<- main %>%  
          dplyr::filter(site=="ungrazed")%>% 
          dplyr::select(1,32:43)

both<- main %>%  
          dplyr::select(1,32:43)

head(grazed); head(ungrazed); head(both)

         
```


```{r labels, echo= TRUE}

  # Labels for family:
 famlab<- c("Muridae","Muridae","Muridae","Caviidae","Caviidae","Canidae","Mephitidae","Dasypodidae","Teiidae","Ctenomyidae","Bovidae","Equidae")

 expfamlab<- c("Rod_Muridae","Rod_Muridae","Rod_Muridae","Rod_Caviidae","Rod_Caviidae","Car_Canidae","Car_Mephitidae","Xen_Dasypodidae","Lac_Teiidae","Rod_Ctenomyidae","Arty_Bovidae","Peri_Equidae")
  #
  
```
  
  
  ## Plotting the interaction networks by site.
  
  ## For each site, with node labels, weighted adjacency matrices.
 
```{r plots_by_site, fig.width=9, eval= T}
  # Plotting bipartite networks from adjacency matrix of two-mode network.
  # Using ggplot2 -----------------------------------------------------------
  # 
 require(ggnetwork)
  
  # Bipartite network initialization, starting from an adjacency matrix.
  # Adjacency matrix (wG and wUG) from dataframe (grazed and ungrazed).
 
 wG<-t(grazed[,2:13])
 colnames(wG)<- grazed[,1]
 netwG<-network::network(wG, matrix.type= 'bipartite', ignore.eval= T)
  

 wUG<-t(ungrazed[,2:13])
 colnames(wUG)<- ungrazed[,1]
 netwUG<-network::network(wUG, matrix.type= 'bipartite', ignore.eval= T)
 
  
  # Function to compute edge weights, scaled.
 edge.weights<- function(M, x = 10) {
      # Edge list and weights.
      M <- cbind(expand.grid(dimnames(M))[2:1], as.vector(M))
      # Discard null weights.
      M <- subset(M, M[, 3] != 0)
      M <- subset(M, M[, 3] != 0) 
      # Scaled weights.
      M.scaled <- x*log(M[, 3] + 1) / max(log(M[, 3] + 1))
      # Vector of edge weights.
      return(M.scaled)
 }

   
  # Weighted bipartite networks
  # 
 # GRAZED
 bipwG= network(wG,
                matrix.type = "bipartite",
                ignore.eval = FALSE,
                names.eval = "weights",
               modes = c("Frug", "Trees"))
 
  # set colors for each mode
#col = c("actor" = "grey", "event" = "gold")


G<-ggnet2(bipwG, size = 5 ,
        edge.size= edge.weights(wG, 5), edge.alpha= .25,
         label= T, label.size= 1.5,
         color= "mode", palette = "Set2",
         shape= "mode") 
G


 # UNGRAZED
bipwUG= network(wUG,
                matrix.type = "bipartite",
                ignore.eval = FALSE,
                names.eval = "weights",
               modes = c("Frug", "Trees"))
  # set colors for each mode
  #col = c("actor" = "grey", "event" = "gold")
  
 Ug<-ggnet2(bipwUG, node.size = 5,
        edge.size= edge.weights(wUG, 5), edge.alpha= .25,
         label= TRUE, label.size= 1.5,
         color= "mode", palette = "Set2",
         shape= "mode")
 Ug
 

```
```{r saving network plots}

ggsave("Grazed network.jpg", plot = last_plot(), device = "jpg", path = NULL,
  scale = 1, width = 16.6, height = 8, units = "cm",
  dpi = 300)

ggsave("Ungrazed network.jpg", plot = last_plot(), device = "jpg", path = NULL,
  scale = 1, width = 16.6, height = 8, units = "cm",
  dpi = 300)

```



#Plot bipartite network for all trees 

```{r plot_all_trees, fig.width=9, eval= T}

# Plotting bipartite networks from adjacency matrix of two-mode network.
  # Using ggplot2 -----------------------------------------------------------
  # 
 require(ggnetwork)
  
  # Bipartite network initialization, starting from an adjacency matrix.
  # Matrix from dataframe.
 

wboth<-t(both[,2:13])
 colnames(wboth)<- both[,1]
 netwboth<-network::network(both, matrix.type= 'bipartite', ignore.eval= T)
  
  # Function to compute edge weights, scaled.
 edge.weights<- function(M, x = 10) {
      # Edge list and weights.
      M <- cbind(expand.grid(dimnames(M))[2:1], as.vector(M))
      # Discard null weights.
      M <- subset(M, M[, 3] != 0)
      M <- subset(M, M[, 3] != 0) 
      # Scaled weights.
      M.scaled <- x*log(M[, 3] + 1) / max(log(M[, 3] + 1))
      # Vector of edge weights.
      return(M.scaled)
  }

 # Weighted bipartite networks
  # 
# Both land uses
 bipwboth= network(wboth,
                matrix.type = "bipartite",
                ignore.eval = FALSE,
                names.eval = "weights",
               modes = c("Frug", "Trees"))
 
  # set colors for each mode
  # col = c("actor" = "grey", "event" = "gold")
  
 ggnet2(bipwboth, node.size = 5,
        edge.size= edge.weights(wboth, 5), edge.alpha= .25,
         label= TRUE, label.size= 3,
         color= "mode", palette = "Set2",
         shape= "mode")
```

#Calculate Connectance, Modularity and Hamming Distance between networks
Bipartite provides functions to visualise webs and calculate a series of indices commonly used to describe pattern in (ecological) networks trees as columns (m) and frugivore species (n) as rows, n x m matrix.

### GRAZED

```{r}
library(bipartite)
```

```{r indices, echo= TRUE, message= TRUE, warning= TRUE}

splevelG<-specieslevel(wG)# This gives you a lot of parameters level="higher" or level="lower"
# for each species and each Prosopis tree
splevelG

spG<-specieslevel(wG,level="higher")
spG

write.csv(spUG,file="spUG.csv")

sp<-specieslevel(wG,level="lower")
sp

spUG<-specieslevel(wUG, level= "higher") # This gives you a lot of parameters
# for each species and each Prosopis tree
splevelUG

networklevel(wG, index="ALLBUTDD", level="both", weighted=TRUE, 
   ISAmethod="Bluethgen",  SAmethod = "Bluethgen", extinctmethod = "r", 
   nrep = 100, CCfun=median, dist="horn", normalise=TRUE, empty.web=TRUE, 
   logbase="e", intereven="prod", H2_integer=TRUE, fcweighted=TRUE, 
   fcdist="euclidean", legacy=FALSE)

grouplevel(wG, index="ALLBUTDD", level="both", weighted=TRUE, empty.web=TRUE, 
dist="horn", CCfun=mean, logbase="e", normalise=TRUE,  extinctmethod="r", 
nrep=100, fcdist="euclidean", fcweighted=TRUE)

networklevel(wUG, index="ALLBUTDD", level="both", weighted=TRUE, 
   ISAmethod="Bluethgen",  SAmethod = "Bluethgen", extinctmethod = "r", 
   nrep = 100, CCfun=median, dist="horn", normalise=TRUE, empty.web=TRUE, 
   logbase="e", intereven="prod", H2_integer=TRUE, fcweighted=TRUE, 
   fcdist="euclidean", legacy=FALSE)

grouplevel(wUG, index="ALLBUTDD", level="both", weighted=TRUE, empty.web=TRUE, 
dist="horn", CCfun=mean, logbase="e", normalise=TRUE,  extinctmethod="r", 
nrep=100, fcdist="euclidean", fcweighted=TRUE)

```

```{r modularity, echo=TRUE, message= TRUE, warning= TRUE}

#Grazed sites
MG<- computeModules(wG, method="Beckett", deep= FALSE, deleteOriginalFiles= FALSE,
                             steps= 1000, tolerance= 1e-10, experimental= FALSE, 
                             forceLPA= FALSE)

MG  #0.5176449

listModuleInformation(MG)

printoutModuleInformation(MG)

plotModuleWeb(MG)

#Ungrazed sites
MUG<- computeModules(wUG, method="Beckett", deep=FALSE, deleteOriginalFiles=FALSE,
                             steps= 1000, tolerance= 1e-10, experimental= FALSE, 
                             forceLPA= FALSE)

MUG #0.4084378


listModuleInformation(MUG)

printoutModuleInformation(MUG)

plotModuleWeb(MUG)

#jpeg(filename = "pMUG.jpg",
    # width = 125, height = 48, units = "cm", pointsize = 12,
     #quality = 75,
     #bg = "white", res = 300, family = "", restoreConsole = TRUE,
    # type = c("windows", "cairo"))

#Mboth<- computeModules(wboth, method="Beckett", deep=FALSE, deleteOriginalFiles=FALSE,
                         #   steps= 1000, tolerance= 1e-10, experimental= FALSE, 
                         #    forceLPA= FALSE)

#Mboth

#listModuleInformation(Mboth)

#printoutModuleInformation(Mboth)

#plotModuleWeb(Mboth)


```
```{r czvalues}

czGf<-czvalues(MG, weighted=TRUE, level="lower")
czGf

czGp<-czvalues(MG, weighted=TRUE, level="higher")
czGp

czUGf<-czvalues(MUG, weighted=TRUE, level="lower")
czUGf

czUGp<-czvalues(MUG, weighted=TRUE, level="higher")
czUGp

```


```{r mod_signif, echo=FALSE, message= TRUE, warning= TRUE}

#Grazed sites
# --------------------------------------------------------------------
# [Title]: Modularity analysis.
# [Date]: 11Jun2013     [Loc]: Sevilla
# Pedro Jordano.
# --------------------------------------------------------------------
## First version 11Jun2013 Revised DATE
# --------------------------------------------------------------------
# Interaction matrices to compute the modularity.
mymat<- wG                        # [Assign here]
#
# Batch to generate the null models for modularity M significance test. ----- 
# (for each matrix, @30 min for 100 null replicates)
require(bipartite)
TIME <- Sys.time()
# Modularity for observed matrix.
# Give here the mean observed modularity values.
mod_obs <- 0.5176449              # [Assign here]
#
Msig <- function (mat, mlike)  {
    require(bipartite)
    # mat is the input matrix for which M is tested
    # mlike is the observed mean M value
    nulls <- nullmodel(mymat, N=100, method=3)
    modules.nulls <- sapply(nulls, computeModules)
    like.nulls <- sapply(modules.nulls, function(x) x@likelihood)
    z <- (mlike - mean(like.nulls))/sd(like.nulls)
    p <- 2*pnorm(-abs(z))
    cat("\n\n","P value for modularity M= ", mod_obs, "\n", "\n\n",
        "zeta=  ", z,
        "P=  ",format(p, scientific = T),"\n\n")
        } 
#
Msig(mymat, mod_obs)
#
Sys.time() - TIME 
#

#Ungrazed sites
mymat<- wUG                        # [Assign here]
#
# Batch to generate the null models for modularity M significance test. ----- 
# (for each matrix, @30 min for 100 null replicates)
require(bipartite)
TIME <- Sys.time()
# Modularity for observed matrix.
# Give here the mean observed modularity values.
mod_obs <- 0.4084378              # [Assign here]
#
Msig <- function (mat, mlike)  {
    require(bipartite)
    # mat is the input matrix for which M is tested
    # mlike is the observed mean M value
    nulls <- nullmodel(mymat, N=100, method=3)
    modules.nulls <- sapply(nulls, computeModules)
    like.nulls <- sapply(modules.nulls, function(x) x@likelihood)
    z <- (mlike - mean(like.nulls))/sd(like.nulls)
    p <- 2*pnorm(-abs(z))
    cat("\n\n","P value for modularity M= ", mod_obs, "\n", "\n\n",
        "zeta=  ", z,
        "P=  ",format(p, scientific = T),"\n\n")
        } 
#
Msig(mymat, mod_obs)
#
Sys.time() - TIME 

```

### Hamming Distance, library(sna)

Is the number of addition/deletion operations required to turn the edge set of G_1 into that of G_2.The Hamming distance is extremely sensitive to nodal labeling, and should not be employed directly when nodes are interchangeable. G_1 and G_2 are labeled graphs

```{r mod_signif, echo=FALSE, message= TRUE, warning= TRUE}

#Grazed sites
#
#
#
#
```

--------------------------

```{r session_info }
sessionInfo()

```







